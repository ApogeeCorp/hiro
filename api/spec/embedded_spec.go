// ----------------------------------------------------------------------------
// Code generated by `swagger generate operation`. DO NOT EDIT.
//
// ----------------------------------------------------------------------------

package spec

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/go-openapi/loads"
)

var (
	// SwaggerJSON embedded version of the swagger document used at generation time
	SwaggerJSON json.RawMessage
	// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time
	FlatSwaggerJSON json.RawMessage

	SpecDoc *loads.Document
)

func init() {
	SwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json",
    "application/x-www-form-urlencoded"
  ],
  "produces": [
    "application/json",
    "application/xml"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "The Hiro API is a foundational API for Model Rocket projects, projects extend this API\nto provide their own services. This API provide the necessary structures and handlers\nfor OAuth 2.0 user authentication, autorization, and management.\n\n# Authentication\n\nWith the exception of the authentication operations themselves (those tagged ` + "`" + `Auth` + "`" + `), all api\ncalls require a valid ` + "`" + `Bearer` + "`" + ` token in the HTTP ` + "`" + `Authorization` + "`" + ` header. These tokens are\ngenerated using the ` + "`" + `libatomic/oauth` + "`" + ` processor.\n\n# Object Identifier\n\nInternally all objects are idenfied using a uuid. Externally, these ids are base58 encoded.\nCalls to API operations should always use the base58 values.\n\n# Errors\n\nThe API uses standard HTTP status codes to indicate the success or failure\nof the API call. The body of the response will be JSON in the following\nformat:\n` + "`" + `` + "`" + `` + "`" + `\n{\n  \"message\": \"object not found\",\n  \"detail\": \"customer xyx does not exist\",\n}\n` + "`" + `` + "`" + `` + "`" + `\n",
    "title": "Hiro API",
    "version": "1.0.0"
  },
  "paths": {
    "/audience": {
      "get": {
        "security": [
          {
            "OAuth": [
              "audience:read"
            ]
          }
        ],
        "description": "Query for a list of audiences.\n",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Hiro"
        ],
        "operationId": "AudienceList",
        "parameters": [
          {
            "type": "integer",
            "format": "uint64",
            "description": "The query offset",
            "name": "offset",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "uint64",
            "default": 1000,
            "description": "The response limit",
            "name": "limit",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv",
            "description": "The application type",
            "name": "type",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Preload child objects of the application, permissions, etc.",
            "name": "preload",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Audience"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "Address": {
      "description": "OpenID address claim as defined in section 5.1.1 of the connect core 1.0 specification",
      "type": "object",
      "properties": {
        "country": {
          "description": "Country name component.",
          "type": "string",
          "x-nullable": true
        },
        "formatted": {
          "description": "Full mailing address, formatted for display or use on a mailing label. This field MAY contain multiple lines, separated by newlines. \nNewlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        },
        "locality": {
          "description": "City or locality component.",
          "type": "string",
          "x-nullable": true
        },
        "postal_code": {
          "description": "Zip code or postal code component.",
          "type": "string",
          "x-nullable": true
        },
        "region": {
          "description": "State, province, prefecture, or region component.",
          "type": "string",
          "x-nullable": true
        },
        "street_address": {
          "description": "Full street address component, which MAY include house number, street name, Post Office Box, and multi-line extended street address \ninformation. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line \nfeed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        }
      }
    },
    "Application": {
      "description": "Applications are API clients that access APIs managed by the integration\nservice. Applications may provide user authentication flows.\nApplications are managed by the ` + "`" + `oauth.Controller` + "`" + `. This library provides\nan incomplete base definition for application clients.\n\n## API URLs\nThis is an array of the application's allowed application uris. These are checked\nin the ` + "`" + `/oauth/authorize` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n\n  - ` + "`" + `auth_request` + "`" + `: An encoded and signed request value to be forwarded to various posts.\n\n## Redirect URIs\nThis is an array of the application's allowed redirect uris. These are checked\nin the ` + "`" + `/oauth/login` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n\n- ` + "`" + `code` + "`" + `: A signed authorization code that can be passed to the ` + "`" + `/oauth/token` + "`" + ` path.\n",
      "type": "object",
      "properties": {
        "allowed_grants": {
          "$ref": "#/definitions/PermissionSet"
        },
        "app_uris": {
          "$ref": "#/definitions/PermissionSet"
        },
        "client_id": {
          "description": "The application client id used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "client_secret": {
          "description": "The application client secret used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "created_at": {
          "description": "The application creation date",
          "type": "string",
          "format": "date-time"
        },
        "description": {
          "description": "The application description",
          "type": "string",
          "x-nullable": true
        },
        "id": {
          "description": "The application id is an alias for client_id",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "name": {
          "description": "The application name",
          "type": "string",
          "x-nullable": false
        },
        "permissions": {
          "$ref": "#/definitions/PermissionSet"
        },
        "redirect_uris": {
          "$ref": "#/definitions/PermissionSet"
        },
        "token_lifetime": {
          "description": "The lifetime for identity tokens in seconds, provided the call requested the \n` + "`" + `openid` + "`" + ` scopes.\n",
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "The application type",
          "type": "string",
          "enum": [
            "web",
            "native",
            "machine"
          ]
        },
        "updated_at": {
          "description": "The last update date",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "Audience": {
      "description": "An audience is an API instance that applications can request permission to access on behalf of\na user or itself.\n",
      "properties": {
        "created_at": {
          "description": "The application creation date",
          "type": "string",
          "format": "date-time"
        },
        "id": {
          "description": "The unique audience id assigned by the server",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "name": {
          "description": "The audience name",
          "type": "string"
        },
        "permissions": {
          "$ref": "#/definitions/Permissions"
        },
        "token_algorithm": {
          "description": "The audience token signing algorithm",
          "type": "string",
          "default": "RS256",
          "enum": [
            "RS256",
            "HS256"
          ],
          "x-nullable": false
        },
        "token_lifetime": {
          "description": "The lifetime for tokens created on behalf of this audience, in seconds",
          "type": "integer",
          "format": "int64",
          "default": 3600,
          "x-nullable": false
        },
        "token_secret": {
          "description": "The signing secret used if the algorithm is HS256",
          "type": "string"
        },
        "updated_at": {
          "description": "The last update date",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "BearerToken": {
      "description": "BearerTokens are returned by the ` + "`" + `/oauth/token` + "`" + ` method. These token always include\nan ` + "`" + `access_token` + "`" + ` which can be used to access api methods from a related service.\nThese are the only objects managed by the api itself. The integration is expected\nto implement the ` + "`" + `oauth.Controller` + "`" + ` interface.\n",
      "type": "object",
      "required": [
        "token_type",
        "access_token",
        "expires_in"
      ],
      "properties": {
        "access_token": {
          "description": "The token to be used for authorization",
          "type": "string",
          "x-nullable": false
        },
        "expires_in": {
          "description": "The time from ` + "`" + `now` + "`" + ` that the token expires",
          "type": "integer",
          "format": "int64",
          "x-nullable": false
        },
        "id_token": {
          "description": "The idenity token contains claims about the users identity. This token is\nreturned if the ` + "`" + `openid` + "`" + ` scope was granted.\nIf the ` + "`" + `profile` + "`" + ` scope was granted, this will contain the user profile.\nThese scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "refresh_token": {
          "description": "The refresh token maybe used to generate a new access token so client\nand user credentials do not have to traverse the wire again.\nThe is provided if the ` + "`" + `offline_access` + "`" + ` scope is request.\nThis scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "token_type": {
          "description": "The token type, always Bearer",
          "type": "string",
          "enum": [
            "bearer"
          ],
          "x-nullable": false
        }
      },
      "additionalProperties": {
        "description": "Additional properties added by the platform",
        "type": "object",
        "additionalProperties": {
          "type": "object"
        }
      }
    },
    "ErrorResponse": {
      "description": "A common error response",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "detail": {
          "description": "The error detail",
          "type": "string"
        },
        "message": {
          "description": "The error message",
          "type": "string",
          "x-nullable": false
        }
      }
    },
    "Metadata": {
      "description": "Metadata is a basic hash type",
      "type": "object",
      "additionalProperties": {
        "type": "object"
      }
    },
    "PermissionSet": {
      "description": "A set of permissions grouped by audience.\n",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Permissions"
      }
    },
    "Permissions": {
      "description": "Permissions are used for both OAuth scopes and API permission lists.\n",
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-omitempty": true
    },
    "Profile": {
      "description": "A profile object based on the [openid connect standard](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).\n",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/Address"
        },
        "birthdate": {
          "description": "End-User's birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. \nTo represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just \nyear can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.\"\n",
          "type": "string",
          "format": "date",
          "x-nullable": true
        },
        "email": {
          "description": "The user's email address",
          "type": "string",
          "format": "email"
        },
        "email_verified": {
          "description": "True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. \nThe means by which an e-mail address is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating.\n",
          "type": "boolean"
        },
        "family_name": {
          "description": "Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "gender": {
          "description": "End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither \nof the defined values are applicable.\n",
          "type": "string"
        },
        "given_name": {
          "description": "Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "locale": {
          "description": "End-User's locale, represented as a BCP47 [RFC5646] language tag. This is typically an ISO 639-1 Alpha-2 [ISO639‑1] language code in lowercase \nand an ISO 3166-1 Alpha-2 [ISO3166‑1] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, \nsome implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept \nthis locale syntax as well.\n",
          "type": "string",
          "default": "en-US"
        },
        "middle_name": {
          "description": "Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; \nall can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.\n",
          "type": "string"
        },
        "name": {
          "description": "End-User's full name in displayable form including all name parts, possibly including titles and suffixes, \nordered according to the End-User's locale and preferences.\n",
          "type": "string"
        },
        "nickname": {
          "description": "Casual name of the End-User that may or may not be the same as the given_name. For instance, \na nickname value of Mike might be returned alongside a given_name value of Michael.\n",
          "type": "string"
        },
        "phone_number": {
          "description": "The user's phone number in E.164 format",
          "type": "string"
        },
        "phone_number_verified": {
          "description": "True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. \nThe means by which a phone number is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be \nrepresented in RFC 3966 format.\"\n",
          "type": "boolean"
        },
        "picture": {
          "description": "URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), \nrather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the \nEnd-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.\n",
          "type": "string"
        },
        "preferred_username": {
          "description": "Shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid \nJSON string including special characters such as @, /, or whitespace. The RP MUST NOT rely upon this value being unique.\n",
          "type": "string"
        },
        "profile": {
          "description": "URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User.\n",
          "type": "string",
          "format": "uri"
        },
        "sub": {
          "description": "Subject - Identifier for the End-User at the Issuer.\n",
          "type": "string",
          "x-go-name": "Subject"
        },
        "updated_at": {
          "description": "Time the End-User's information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z\nas measured in UTC until the date/time.\n",
          "type": "integer",
          "format": "int64"
        },
        "website": {
          "description": "URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an \norganization that the End-User is affiliated with.\n",
          "type": "string"
        },
        "zoneinfo": {
          "description": "String from zoneinfo [zoneinfo] time zone database representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles.\n",
          "type": "string"
        }
      },
      "x-nullable": true
    },
    "User": {
      "description": "A user is a user object\n",
      "type": "object",
      "required": [
        "login"
      ],
      "properties": {
        "created_at": {
          "description": "The user creation date",
          "type": "string",
          "format": "date-time"
        },
        "id": {
          "description": "The user id",
          "type": "string"
        },
        "login": {
          "description": "The user's login\n",
          "type": "string",
          "x-nullable": false
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "password_expires_at": {
          "description": "The time the user password expirts",
          "type": "string",
          "format": "date-time",
          "x-nullable": false
        },
        "permissions": {
          "$ref": "#/definitions/PermissionSet"
        },
        "profile": {
          "$ref": "#/definitions/Profile"
        },
        "roles": {
          "$ref": "#/definitions/PermissionSet"
        },
        "updated_at": {
          "description": "The last update date",
          "type": "string",
          "format": "date-time"
        }
      }
    }
  },
  "securityDefinitions": {
    "OAuth": {
      "type": "oauth2",
      "flow": "accessCode",
      "authorizationUrl": "https://auth.server.local/api/1.0.0/oauth/authorize",
      "tokenUrl": "https://auth.server.local/api/1.0.0/oauth/token",
      "scopes": {
        "application:read": "Read application objects",
        "application:write": "Write application objects",
        "audience:read": "Read audience objects",
        "audience:write": "Write audience objects",
        "email:verify": "Required to verify a user's email address",
        "offline_access": "Used by clients to request permission to use refresh tokens",
        "openid": "Access a user's identity",
        "profile": "Access a user's profile",
        "user:read": "Read user objects",
        "user:write": "Write user objects"
      }
    }
  },
  "tags": [
    {
      "description": "Administrative operations provide lower level admin services like direct user creation.\n",
      "name": "Admin"
    },
    {
      "description": "User operations provide services to the user like getting profile data and setting passwords.\n",
      "name": "User"
    },
    {
      "description": "Auth operations provide signup, login and authorization services.\n",
      "name": "Auth"
    }
  ]
}`))
	FlatSwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json",
    "application/x-www-form-urlencoded"
  ],
  "produces": [
    "application/json",
    "application/xml"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "The Hiro API is a foundational API for Model Rocket projects, projects extend this API\nto provide their own services. This API provide the necessary structures and handlers\nfor OAuth 2.0 user authentication, autorization, and management.\n\n# Authentication\n\nWith the exception of the authentication operations themselves (those tagged ` + "`" + `Auth` + "`" + `), all api\ncalls require a valid ` + "`" + `Bearer` + "`" + ` token in the HTTP ` + "`" + `Authorization` + "`" + ` header. These tokens are\ngenerated using the ` + "`" + `libatomic/oauth` + "`" + ` processor.\n\n# Object Identifier\n\nInternally all objects are idenfied using a uuid. Externally, these ids are base58 encoded.\nCalls to API operations should always use the base58 values.\n\n# Errors\n\nThe API uses standard HTTP status codes to indicate the success or failure\nof the API call. The body of the response will be JSON in the following\nformat:\n` + "`" + `` + "`" + `` + "`" + `\n{\n  \"message\": \"object not found\",\n  \"detail\": \"customer xyx does not exist\",\n}\n` + "`" + `` + "`" + `` + "`" + `\n",
    "title": "Hiro API",
    "version": "1.0.0"
  },
  "paths": {
    "/audience": {
      "get": {
        "security": [
          {
            "OAuth": [
              "audience:read"
            ]
          }
        ],
        "description": "Query for a list of audiences.\n",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "tags": [
          "Hiro"
        ],
        "operationId": "AudienceList",
        "parameters": [
          {
            "type": "integer",
            "format": "uint64",
            "description": "The query offset",
            "name": "offset",
            "in": "query"
          },
          {
            "type": "integer",
            "format": "uint64",
            "default": 1000,
            "description": "The response limit",
            "name": "limit",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "csv",
            "description": "The application type",
            "name": "type",
            "in": "query"
          },
          {
            "type": "boolean",
            "description": "Preload child objects of the application, permissions, etc.",
            "name": "preload",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Audience"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "Address": {
      "description": "OpenID address claim as defined in section 5.1.1 of the connect core 1.0 specification",
      "type": "object",
      "properties": {
        "country": {
          "description": "Country name component.",
          "type": "string",
          "x-nullable": true
        },
        "formatted": {
          "description": "Full mailing address, formatted for display or use on a mailing label. This field MAY contain multiple lines, separated by newlines. \nNewlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        },
        "locality": {
          "description": "City or locality component.",
          "type": "string",
          "x-nullable": true
        },
        "postal_code": {
          "description": "Zip code or postal code component.",
          "type": "string",
          "x-nullable": true
        },
        "region": {
          "description": "State, province, prefecture, or region component.",
          "type": "string",
          "x-nullable": true
        },
        "street_address": {
          "description": "Full street address component, which MAY include house number, street name, Post Office Box, and multi-line extended street address \ninformation. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line \nfeed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        }
      }
    },
    "Application": {
      "description": "Applications are API clients that access APIs managed by the integration\nservice. Applications may provide user authentication flows.\nApplications are managed by the ` + "`" + `oauth.Controller` + "`" + `. This library provides\nan incomplete base definition for application clients.\n\n## API URLs\nThis is an array of the application's allowed application uris. These are checked\nin the ` + "`" + `/oauth/authorize` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n\n  - ` + "`" + `auth_request` + "`" + `: An encoded and signed request value to be forwarded to various posts.\n\n## Redirect URIs\nThis is an array of the application's allowed redirect uris. These are checked\nin the ` + "`" + `/oauth/login` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n\n- ` + "`" + `code` + "`" + `: A signed authorization code that can be passed to the ` + "`" + `/oauth/token` + "`" + ` path.\n",
      "type": "object",
      "properties": {
        "allowed_grants": {
          "$ref": "#/definitions/PermissionSet"
        },
        "app_uris": {
          "$ref": "#/definitions/PermissionSet"
        },
        "client_id": {
          "description": "The application client id used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "client_secret": {
          "description": "The application client secret used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "created_at": {
          "description": "The application creation date",
          "type": "string",
          "format": "date-time"
        },
        "description": {
          "description": "The application description",
          "type": "string",
          "x-nullable": true
        },
        "id": {
          "description": "The application id is an alias for client_id",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "name": {
          "description": "The application name",
          "type": "string",
          "x-nullable": false
        },
        "permissions": {
          "$ref": "#/definitions/PermissionSet"
        },
        "redirect_uris": {
          "$ref": "#/definitions/PermissionSet"
        },
        "token_lifetime": {
          "description": "The lifetime for identity tokens in seconds, provided the call requested the \n` + "`" + `openid` + "`" + ` scopes.\n",
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "The application type",
          "type": "string",
          "enum": [
            "web",
            "native",
            "machine"
          ]
        },
        "updated_at": {
          "description": "The last update date",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "Audience": {
      "description": "An audience is an API instance that applications can request permission to access on behalf of\na user or itself.\n",
      "properties": {
        "created_at": {
          "description": "The application creation date",
          "type": "string",
          "format": "date-time"
        },
        "id": {
          "description": "The unique audience id assigned by the server",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "name": {
          "description": "The audience name",
          "type": "string"
        },
        "permissions": {
          "$ref": "#/definitions/Permissions"
        },
        "token_algorithm": {
          "description": "The audience token signing algorithm",
          "type": "string",
          "default": "RS256",
          "enum": [
            "RS256",
            "HS256"
          ],
          "x-nullable": false
        },
        "token_lifetime": {
          "description": "The lifetime for tokens created on behalf of this audience, in seconds",
          "type": "integer",
          "format": "int64",
          "default": 3600,
          "x-nullable": false
        },
        "token_secret": {
          "description": "The signing secret used if the algorithm is HS256",
          "type": "string"
        },
        "updated_at": {
          "description": "The last update date",
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "BearerToken": {
      "description": "BearerTokens are returned by the ` + "`" + `/oauth/token` + "`" + ` method. These token always include\nan ` + "`" + `access_token` + "`" + ` which can be used to access api methods from a related service.\nThese are the only objects managed by the api itself. The integration is expected\nto implement the ` + "`" + `oauth.Controller` + "`" + ` interface.\n",
      "type": "object",
      "required": [
        "token_type",
        "access_token",
        "expires_in"
      ],
      "properties": {
        "access_token": {
          "description": "The token to be used for authorization",
          "type": "string",
          "x-nullable": false
        },
        "expires_in": {
          "description": "The time from ` + "`" + `now` + "`" + ` that the token expires",
          "type": "integer",
          "format": "int64",
          "x-nullable": false
        },
        "id_token": {
          "description": "The idenity token contains claims about the users identity. This token is\nreturned if the ` + "`" + `openid` + "`" + ` scope was granted.\nIf the ` + "`" + `profile` + "`" + ` scope was granted, this will contain the user profile.\nThese scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "refresh_token": {
          "description": "The refresh token maybe used to generate a new access token so client\nand user credentials do not have to traverse the wire again.\nThe is provided if the ` + "`" + `offline_access` + "`" + ` scope is request.\nThis scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "token_type": {
          "description": "The token type, always Bearer",
          "type": "string",
          "enum": [
            "bearer"
          ],
          "x-nullable": false
        }
      },
      "additionalProperties": {
        "description": "Additional properties added by the platform",
        "type": "object",
        "additionalProperties": {
          "type": "object"
        }
      }
    },
    "ErrorResponse": {
      "description": "A common error response",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "detail": {
          "description": "The error detail",
          "type": "string"
        },
        "message": {
          "description": "The error message",
          "type": "string",
          "x-nullable": false
        }
      }
    },
    "Metadata": {
      "description": "Metadata is a basic hash type",
      "type": "object",
      "additionalProperties": {
        "type": "object"
      }
    },
    "PermissionSet": {
      "description": "A set of permissions grouped by audience.\n",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Permissions"
      }
    },
    "Permissions": {
      "description": "Permissions are used for both OAuth scopes and API permission lists.\n",
      "type": "array",
      "items": {
        "type": "string"
      },
      "x-omitempty": true
    },
    "Profile": {
      "description": "A profile object based on the [openid connect standard](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).\n",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/Address"
        },
        "birthdate": {
          "description": "End-User's birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. \nTo represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just \nyear can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.\"\n",
          "type": "string",
          "format": "date",
          "x-nullable": true
        },
        "email": {
          "description": "The user's email address",
          "type": "string",
          "format": "email"
        },
        "email_verified": {
          "description": "True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. \nThe means by which an e-mail address is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating.\n",
          "type": "boolean"
        },
        "family_name": {
          "description": "Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "gender": {
          "description": "End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither \nof the defined values are applicable.\n",
          "type": "string"
        },
        "given_name": {
          "description": "Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "locale": {
          "description": "End-User's locale, represented as a BCP47 [RFC5646] language tag. This is typically an ISO 639-1 Alpha-2 [ISO639‑1] language code in lowercase \nand an ISO 3166-1 Alpha-2 [ISO3166‑1] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, \nsome implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept \nthis locale syntax as well.\n",
          "type": "string",
          "default": "en-US"
        },
        "middle_name": {
          "description": "Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; \nall can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.\n",
          "type": "string"
        },
        "name": {
          "description": "End-User's full name in displayable form including all name parts, possibly including titles and suffixes, \nordered according to the End-User's locale and preferences.\n",
          "type": "string"
        },
        "nickname": {
          "description": "Casual name of the End-User that may or may not be the same as the given_name. For instance, \na nickname value of Mike might be returned alongside a given_name value of Michael.\n",
          "type": "string"
        },
        "phone_number": {
          "description": "The user's phone number in E.164 format",
          "type": "string"
        },
        "phone_number_verified": {
          "description": "True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. \nThe means by which a phone number is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be \nrepresented in RFC 3966 format.\"\n",
          "type": "boolean"
        },
        "picture": {
          "description": "URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), \nrather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the \nEnd-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.\n",
          "type": "string"
        },
        "preferred_username": {
          "description": "Shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid \nJSON string including special characters such as @, /, or whitespace. The RP MUST NOT rely upon this value being unique.\n",
          "type": "string"
        },
        "profile": {
          "description": "URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User.\n",
          "type": "string",
          "format": "uri"
        },
        "sub": {
          "description": "Subject - Identifier for the End-User at the Issuer.\n",
          "type": "string",
          "x-go-name": "Subject"
        },
        "updated_at": {
          "description": "Time the End-User's information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z\nas measured in UTC until the date/time.\n",
          "type": "integer",
          "format": "int64"
        },
        "website": {
          "description": "URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an \norganization that the End-User is affiliated with.\n",
          "type": "string"
        },
        "zoneinfo": {
          "description": "String from zoneinfo [zoneinfo] time zone database representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles.\n",
          "type": "string"
        }
      },
      "x-nullable": true
    },
    "User": {
      "description": "A user is a user object\n",
      "type": "object",
      "required": [
        "login"
      ],
      "properties": {
        "created_at": {
          "description": "The user creation date",
          "type": "string",
          "format": "date-time"
        },
        "id": {
          "description": "The user id",
          "type": "string"
        },
        "login": {
          "description": "The user's login\n",
          "type": "string",
          "x-nullable": false
        },
        "metadata": {
          "$ref": "#/definitions/Metadata"
        },
        "password_expires_at": {
          "description": "The time the user password expirts",
          "type": "string",
          "format": "date-time",
          "x-nullable": false
        },
        "permissions": {
          "$ref": "#/definitions/PermissionSet"
        },
        "profile": {
          "$ref": "#/definitions/Profile"
        },
        "roles": {
          "$ref": "#/definitions/PermissionSet"
        },
        "updated_at": {
          "description": "The last update date",
          "type": "string",
          "format": "date-time"
        }
      }
    }
  },
  "securityDefinitions": {
    "OAuth": {
      "type": "oauth2",
      "flow": "accessCode",
      "authorizationUrl": "https://auth.server.local/api/1.0.0/oauth/authorize",
      "tokenUrl": "https://auth.server.local/api/1.0.0/oauth/token",
      "scopes": {
        "application:read": "Read application objects",
        "application:write": "Write application objects",
        "audience:read": "Read audience objects",
        "audience:write": "Write audience objects",
        "email:verify": "Required to verify a user's email address",
        "offline_access": "Used by clients to request permission to use refresh tokens",
        "openid": "Access a user's identity",
        "profile": "Access a user's profile",
        "user:read": "Read user objects",
        "user:write": "Write user objects"
      }
    }
  },
  "tags": [
    {
      "description": "Administrative operations provide lower level admin services like direct user creation.\n",
      "name": "Admin"
    },
    {
      "description": "User operations provide services to the user like getting profile data and setting passwords.\n",
      "name": "User"
    },
    {
      "description": "Auth operations provide signup, login and authorization services.\n",
      "name": "Auth"
    }
  ]
}`))

	spec, err := loads.Analyzed(SwaggerJSON, "")
	if err != nil {
		panic(fmt.Errorf("analyze swagger: %v", err))
	}
	SpecDoc = spec
}

func specHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	enc := json.NewEncoder(w)
	enc.SetEscapeHTML(false)

	_, pretty := r.URL.Query()["pretty"]

	if pretty {
		enc.SetIndent("", "\t")
	}

	if err := enc.Encode(SwaggerJSON); err != nil {
		panic(err)
	}
}
